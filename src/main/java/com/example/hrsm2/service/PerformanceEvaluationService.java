package com.example.hrsm2.service;

import com.example.hrsm2.model.PerformanceEvaluation;
import com.example.hrsm2.util.DatabaseDriver;

import java.time.LocalDate;
import java.util.List;
import java.util.stream.Collectors; // Keep for filtering by date range

public class PerformanceEvaluationService {
    // Remove in-memory storage:
    // private Map<String, PerformanceEvaluation> evaluations;

    // Add DatabaseDriver instance
    private final DatabaseDriver dbDriver;
    private static PerformanceEvaluationService instance;

    private PerformanceEvaluationService() {
        // Remove HashMap initialization
        // evaluations = new HashMap<>();
        // Initialize DatabaseDriver
        dbDriver = DatabaseDriver.getInstance();
    }

    public static PerformanceEvaluationService getInstance() {
        if (instance == null) {
            instance = new PerformanceEvaluationService();
        }
        return instance;
    }

    // --- Modified CRUD methods using DatabaseDriver ---

    public List<PerformanceEvaluation> getAllEvaluations() {
        // Delegate to DatabaseDriver
        return dbDriver.getAllEvaluations();
    }

    public PerformanceEvaluation getEvaluationById(String id) {
        // Delegate to DatabaseDriver
        return dbDriver.getEvaluationById(id);
    }

    public List<PerformanceEvaluation> getEvaluationsByEmployeeId(String employeeId) {
        // Delegate to DatabaseDriver
        return dbDriver.getEvaluationsByEmployeeId(employeeId);
    }

    public void addEvaluation(PerformanceEvaluation evaluation) {
        // Delegate to DatabaseDriver
        // The evaluation object already has its ID generated by its constructor
        boolean success = dbDriver.insertEvaluation(evaluation);
        if (!success) {
            // Optional: Log error or throw a custom exception
            System.err.println("Failed to add performance evaluation to the database (ID: " + evaluation.getId() + ")");
            // Consider throwing a RuntimeException or a specific ServiceException
            // throw new RuntimeException("Failed to add performance evaluation.");
        }
    }

    public void updateEvaluation(PerformanceEvaluation evaluation) {
        // Delegate to DatabaseDriver
        boolean success = dbDriver.updateEvaluation(evaluation);
        if (!success) {
            System.err.println("Failed to update performance evaluation in the database (ID: " + evaluation.getId() + ")");
            // throw new RuntimeException("Failed to update performance evaluation.");
        }
    }

    public void deleteEvaluation(String id) {
        // Delegate to DatabaseDriver
        boolean success = dbDriver.deleteEvaluation(id);
        if (!success) {
            System.err.println("Failed to delete performance evaluation from the database (ID: " + id + ")");
            // throw new RuntimeException("Failed to delete performance evaluation.");
        }
    }

    // --- Business Logic methods (can remain largely the same, but use DB-backed methods) ---

    public double getAverageRatingForEmployee(String employeeId) {
        // This now uses the DB-backed getEvaluationsByEmployeeId
        List<PerformanceEvaluation> employeeEvaluations = getEvaluationsByEmployeeId(employeeId);

        if (employeeEvaluations.isEmpty()) {
            return 0.0;
        }

        int totalRating = 0;
        for (PerformanceEvaluation evaluation : employeeEvaluations) {
            totalRating += evaluation.getPerformanceRating();
        }

        return (double) totalRating / employeeEvaluations.size();
    }

    public List<PerformanceEvaluation> getEvaluationsByDateRange(LocalDate startDate, LocalDate endDate) {
        // Fetch all evaluations from DB first, then filter in memory.
        // For very large datasets, optimizing this with a specific DB query would be better.
        List<PerformanceEvaluation> allEvaluations = getAllEvaluations(); // Gets from DB now
        return allEvaluations.stream()
                .filter(evaluation ->
                        evaluation.getEvaluationDate() != null && // Add null check
                                !evaluation.getEvaluationDate().isBefore(startDate) &&
                                !evaluation.getEvaluationDate().isAfter(endDate))
                .collect(Collectors.toList());
    }
}